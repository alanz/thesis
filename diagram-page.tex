%!TEX root = paper.tex

\newsavebox{\runningexample}
\begin{lrbox}{\runningexample}
\begin{minipage}{\linewidth}
\begin{alltt}

component p             component base
 required-signature: A   exposed-module: W
 required-signature: B
 exposed-module: Y      component q
                         required-signature: A
component r              exposed-module: X
 required-signature: A
 backpack-include: base (W)
 backpack-include: p (Y) requires (B)
 backpack-include: q (X as B)
 reexported-module: Y as Z
\end{alltt}
\end{minipage}
\end{lrbox}


\newcommand{\figsep}{\vspace*{.2cm}\textcolor{gray}{\rule{\linewidth}{.25pt}}}
\newcommand{\capsep}{\vspace*{.2cm}}%\rule{\linewidth}{.5pt}}

\begin{figure}
  \subfigure%
    [\Ccomp{}s.\label{fig:rcomponents}]%
    {
  \begin{minipage}{\linewidth}
    \[
    \begin{array}{rcl}
    m & & \mbox{Module name} \\
    p, q & & \mbox{\Cid} \\[0.3em]
    \Uhsbody & & \mbox{Module source} \\
    \Uhssig & & \mbox{Signature source} \\
    \Scomp & ::= & \Scomponent{\Up}{\overline{\Sdecl}} \\[0.3em]
    \Sdecl & ::= & \Sinclude{\Up}{\I{rns}} \\
           & |   & \Sexposed{m}{\Uhsbody} \\
           & |   & \Sother{m}{\Uhsbody} \\
           & |   & \Sreexported{m}{m'} \\
           & |   & \Srequired{m}{\Uhssig} \\
    \I{rns} & ::= & [\Slparen\overline{rn}\Srparen]~[\texttt{requires}~ \Slparen\overline{rn'}\Srparen] \\
    \I{rn} & ::= & \Sas{m}{m'} \\
           & |   & m \\
    \end{array}
    \]
    \capsep
    %\subcaption{Syntax of \ccomp{}s}
    % \label{fig:rcomponents}
  \end{minipage}
  }
  \figsep

  \subfigure%
    [Component shapes and \unit{}s.\label{fig:lcomponents}]%
    {
  \begin{minipage}{\linewidth}


%   \caption{Semantic entities for mixin linking (for $M$, see Figure~\ref{fig:lcomponents}).
%   A shape $\{ \overline{m_i} \} \rightarrow \{ \overline{m_j \mapsto M_j} \}$ has
%   the invariant that $\overline{m_i}$ and $\overline{m_j}$ are disjoint.
%   Renamings may be implicitly lifted to a substitution $\overline{m \rightarrow\protect\holevar{m'}}$
%   or a partial functions from $m$ to $m$ (in which case $r_\textsf{R}(\reqs)$ denotes the image of the function on the set $\reqs$).}
%   \label{fig:mixin-semantic-entities}
%   % It's too bad that requires and provides are not symmetric. They can
%   % be made to be but it's a bit confusing.
%   \end{figure}


\[
\begin{array}{lcll}
\lctx & ::= & \lctxpairx{\provs}{\reqs} & \mbox{Component shape} \\
%r_\textsf{R} & ::= & \overline{m \rightarrow m'} & \mbox{Requirement renaming (total)} \\
%r_\textsf{P} & ::= & \overline{m \rightarrow m'} & \mbox{Provision renaming (partial)} \\
\reqs  & ::= & \overline{\hv{m}} & \mbox{Required module variables} \\
\provs & ::= & \overline{\prov{m}{M}}  & \mbox{Provided modules} \\
\shctx & ::= & \overline{\Up \shapeis \lctx} & \mbox{Component shape context} \\
\end{array}
\]
    \[
    \begin{array}{rcll}
      M   &::=& \Mod{\UP}{m} & \text{Module identity} \\
          &|&   \holevar{m} & \text{Module hole} \\
      \UP &::=& \icid{\Up}{S} & \text{\Uid} \\
      S   &::=& \overline{\subst{m}{M}} & \text{Module substitution} \\
    \end{array}
    \]
    \[
    \begin{array}{rcll}
      \Uunit &::=& \UsynUnit{\Up}{\reqs}{\overline{\Uudecl}} & \text{Mixed component} \\
      \Uudecl &::=& \UsynDep{\UP}{r} & \text{Direct dependency} \\
              &|&   \UsynMod{m}{\Uhsbody} & \text{Module definition} \\
              &|&   \UsynSig{m}{\Uhssig} & \text{Signature definition} \\
              %& &   \qquad \textsf{with}~\overline{P\!:\!m} & \quad\text{(Merges)} \\
              %&|&   \UsynLet{m}{M} & \text{Let binding} \\
      %\mprog &::=& \overline{\Uunit} & \text{Mixed program} \\
      r   &::=& \overline{m \mapsto m'} & \text{Module renaming} \\
    \end{array}
    \]
    \capsep
    % \subcaption{Syntax of \unit{}s}
    % \label{fig:lcomponents}
  \end{minipage}
  }
  \caption{Syntax of intermediate languages}
  \label{fig:syntaxes}
\end{figure}



\begin{figure}
\begin{mdframed}
  \subfigure%
    [Heavily simplified version of Figure~\ref{fig:resolved-full-comps} to serve as the running example: \texttt{p} is \texttt{db-dsl}, \texttt{q} is \texttt{mysql-indef} and \texttt{r} is \texttt{mysql-dsl-indef}; signature \texttt{A} is \texttt{Data.ByteString} and signature \texttt{B} is \texttt{Db}.\label{fig:resolved-example}
    ]%
    {
  \hspace{-1em}
  \begin{minipage}{\linewidth}
%     \begin{verbatim}
% component base
%   exposed-module: W
%                          component r
% component p                include: base (W)
%   required-signature: A    include: p (Y) requires (B)
%   required-signature: B    include: q (X as B)
%   exposed-module: Y        required-signature: A
%                            reexported-module: Y as Z
% component q
%   required-signature: A
%   exposed-module: X\end{verbatim}
    % \theverbbox{}\\
    \usebox{\runningexample}
    \capsep
    % \subcaption{Running example, a more compact version of Figure~\ref{fig:resolved-full-example}.
    % The source code is still elided.  By convention, $A, B, C$ are signatures and $X, Y$ are modules.}
    % \label{fig:resolved-example}
  \end{minipage}
  }


  \figsep

  \subfigure%
    [\Unit{}s. Each component is ordered and annotated with its provided modules, as
    $\textsf{component}~p~\overline{\protect\hv{m}}\haspr\{\provs\}$.\label{fig:linked-example}]%
    {
  \hspace{-1em}
  \begin{minipage}{\linewidth}
    \[
    \begin{array}{l}
      \UsynUnitH{\cidl{base}}{} \haspr \{\provMod{W}{\icid{base}{}}{W}\}  \\
      %\quad \UsynLet{W}{\Mod{\icid{base}{}}{W}} \\
      \quad \UsynMod{\modname{W}(\texttt{I}(..))}{\texttt{data I = MkI I; f (MkI i) = i}} \\
      \\
      \UsynUnitH{\cidl{p}}{\hv{\modname{A}}~\hv{\modname{B}}}
        \haspr \{
            \provMod{Y}{%
                \icid{\cidl{p}}{ \subst{A}{\holevar{A}}, \subst{B}{\holevar{B}}  }%
            }{Y} \} \\
      \quad \UsynSig{A}{\texttt{data J}} \\
      \quad \UsynSig{B}{\texttt{data K}} \\
      %\quad \UsynLet{Y}{\MOD{p}{\substHole{A}, \substHole{B}}{Y}} \\
      \quad \UsynMod{Y}{\texttt{import A; import B; data L = MkL J K}} \\
      \\
      \UsynUnitH{\cidl{q}}{\hv{\modname{A}}}
        \haspr \{ \provMod{X}{\icid{\cidl{q}}{\subst{A}{\holevar{A}}}}{X} \}
      \\
      \quad \UsynSig{\modname{A}~(\texttt{I}(..))}{\texttt{data I = MkI I}} \\
      %\quad \UsynLet{X}{\MOD{q}{\substHole{A}}{X}} \\
      \quad \UsynMod{\modname{X}~(\texttt{I}(..), \texttt{K}(..))}{\texttt{import A; data K = MkK I}} \\
      \\
      \UsynUnitH{\cidl{r}}{\hv{\modname{A}}}
        \haspr \{
        \provMod{Z}{\icid{\cidl{p}}{%
                 \subst{A}{\holevar{A}},
                 \substMod{B}{\icid{\cidl{q}}{\subst{A}{\holevar{A}}}}{X}
             }}{Y} \}
        \\
      \quad \UsynDep{\icid{base}{}}{ \rename{W}{W} } \\
      \quad \mathsf{signature}~\modname{A}~(\texttt{I}(..))~\{ \texttt{import W(I(..))} \} \\
      %\quad\quad \textsf{with}~\Mod{\icid{\cidl{q}}{\substHole{A}}}{A},
      %           \Mod{\icid{\cidl{p}}{\substHole{A}, \subst{B}{\ldots}}}{A} \\
      \quad \UsynDep{\icid{\cidl{q}}{\substHole{A}}}{ \rename{X}{B} } \\
      \quad \UsynDep{\icid{\cidl{p}}{\substHole{A}, \substMod{B}{\icid{\cidl{q}}{\substHole{A}}}{X}}}{ \rename{Y}{Y} } \\
    \end{array}
    \]
    % \iffalse%
    % \begin{verbatim}
    % component base[]
    %   let W = base[]:W
    %   module W { data I = MkI I }

    % component p[A,B]
    %   signature A { data J }
    %   signature B { data K }
    %   let Y = p[A=<A>, B=<B>]:Y
    %   module Y { import A; import B; data L = MkL J K }

    % component q[A]
    %   signature A { data I = MkI I }
    %   let X = q[A=<A>]:X
    %   module X { import A; data K = MkK I }

    % component r[A]
    %   dependency base[]
    %   let W = base[]:W
    %   signature A(I(..), J) { import W(I(..)); data J }
    %   dependency q[A=<A>]
    %   dependency p[A=<A>,B=q[A=<A>]:X]
    % \end{verbatim}
    % \fi
    \capsep
    % \subcaption{Running example after mixin linking, with source code included.
    % For clarity, we have topologically sorted the declarations.  The list of exports of a module is technically
    % associated with $\Uhsbody{}$ or $\Uhssig{}$ (and is displayed externally to
    % mimic Haskell's concrete syntax).}
    % \label{fig:linked-example}
  \end{minipage}
  }

  \figsep

  \subfigure%
    [Component types.  The full syntax for types is in Figure~\ref{fig:haskell-semantics}.\label{fig:typing-example}]%
    {
  \hspace{-1em}
  \begin{minipage}{\linewidth}
    \[
    \begin{array}{l}
    \cidl{base}
        : \left\{\right\} \rightarrow
          \left\{
            \modname{W}
            : \begin{array}{l}
                \UobjIface\: (\MOD{base}{}{W}.\texttt{I}, \MOD{base}{}{W}.\texttt{f} ) \\
                \quad\texttt{data I :: * = MkI}\ \MOD{base}{}{W}.\texttt{I} \\
                \quad\texttt{f ::}~\MOD{base}{}{W}.\texttt{I}~\rightarrow~\MOD{base}{}{W}.\texttt{I}
            \end{array}
          \right\}
    \\[2em]
    \cidl{p} : \forall \hv{A} \hv{B}.\, \forall \nhv{\texttt{A.J}} \nhv{\texttt{B.K}}. \\
    \quad
    \left\{
        \modname{A}
          : \begin{array}{l}
                \UobjIface\: (\nhv{\texttt{A.J}}) \\
                \quad\texttt{data J :: *}
            \end{array},\,
        \modname{B}
          : \begin{array}{l}
                \UobjIface\: (\nhv{\texttt{B.K}}) \\
                \quad\texttt{data K :: *}
            \end{array}
    \right\}
    \rightarrow \\
    \quad
    \left\{
        \modname{Y}
          : \begin{array}{l}
                \UobjIface\: (\MOD{p}{\substHole{A}, \substHole{B}}{Y}.\texttt{L}) \\
                \quad\texttt{data L :: * = MkL \nhv{\texttt{A.J}} \nhv{\texttt{B.K}}}
            \end{array}
    \right\}
    \\[2em]
    \cidl{q} : \forall \hv{A}.\, \forall \nhv{\texttt{A.I}}. \\
    \quad
    \left\{
        \modname{A}
          : \begin{array}{l}
                \UobjIface\: (\nhv{\texttt{A.I}}) \\
                \quad\texttt{data I :: * = MkI}\ \nhv{\texttt{A.I}}
            \end{array}
    \right\}
    \rightarrow \\
    \quad
    \left\{
        \modname{X}
          : \begin{array}{l}
                \UobjIface\: (\nhv{\texttt{A.I}}, \MOD{q}{\substHole{A}}{X}.\texttt{K}) \\
                \quad\texttt{data K :: * = MkK \nhv{\texttt{A.I}}}
            \end{array}
    \right\}
    \\[2em]
    \cidl{r} : \forall \hv{A}.\, \forall \nhv{\texttt{A.J}}. \\
    \quad
    \left\{
        \modname{A}
          : \begin{array}{l}
                \UobjIface\: (\MOD{base}{}{W}.\texttt{I}, \nhv{\texttt{A.J}}) \\
                \quad\texttt{data J :: *}
            \end{array}
    \right\}
    \rightarrow
    \left\{
    \right\}
    \end{array}
    \]
    \capsep
    % \subcaption{Component types for running example}
  \end{minipage}
  }

\caption{Syntax, shapes and types for running example}
\label{fig:stuff}
\end{mdframed}
\end{figure}
