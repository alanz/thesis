%!TEX root = paper.tex

\newcommand{\figsep}{\vspace*{.2cm}\textcolor{gray}{\rule{\linewidth}{.25pt}}}
\newcommand{\capsep}{\vspace*{.2cm}}%\rule{\linewidth}{.5pt}}

\begin{figure}
    \[
    \begin{array}{rcl}
    m & & \mbox{Module name} \\
    p, q & & \mbox{\Cid} \\[0.3em]
    \Uhsbody & & \mbox{Module source} \\
    \Uhssig & & \mbox{Signature source} \\
    \Scomp & ::= & \Scomponent{\Up}{\overline{\Sdecl}} \\[0.3em]
    \Sdecl & ::= & \Sinclude{\Up}{\I{rns}} \\
           & |   & \Sexposed{m}{\Uhsbody} \\
           & |   & \Sother{m}{\Uhsbody} \\
           & |   & \Sreexported{m}{m'} \\
           & |   & \Srequired{m}{\Uhssig} \\
    \I{rns} & ::= & [\Slparen\overline{rn}\Srparen]~[\texttt{requires}~ \Slparen\overline{rn'}\Srparen] \\
    \I{rn} & ::= & \Sas{m}{m'} \\
           & |   & m \\
    \end{array}
    \]
    \caption{\Ccomp{}s.}\label{fig:rcomponents}
\end{figure}

\begin{figure}

    \[
    \begin{array}{lcll}
    \lctx & ::= & \lctxpairx{\provs}{\reqs} & \mbox{Component shape} \\
    %r_\textsf{R} & ::= & \overline{m \rightarrow m'} & \mbox{Requirement renaming (total)} \\
    %r_\textsf{P} & ::= & \overline{m \rightarrow m'} & \mbox{Provision renaming (partial)} \\
    \reqs  & ::= & \overline{\hv{m}} & \mbox{Required module variables} \\
    \provs & ::= & \overline{\prov{m}{M}}  & \mbox{Provided modules} \\
    \shctx & ::= & \overline{\Up \shapeis \lctx} & \mbox{Component shape context} \\
    \end{array}
    \]
    \[
    \begin{array}{rcll}
      M   &::=& \Mod{\UP}{m} & \text{Module identity} \\
          &|&   \holevar{m} & \text{Module hole} \\
      \UP &::=& \icid{\Up}{S} & \text{\Uid} \\
      S   &::=& \overline{\subst{m}{M}} & \text{Module substitution} \\
    \end{array}
    \]
    \[
    \begin{array}{rcll}
      \Uunit &::=& \UsynUnit{\Up}{\reqs}{\overline{\Uudecl}} & \text{Mixed component} \\
      \Uudecl &::=& \UsynDep{\UP}{r} & \text{Direct dependency} \\
              &|&   \UsynMod{m}{\Uhsbody} & \text{Module definition} \\
              &|&   \UsynSig{m}{\Uhssig} & \text{Signature definition} \\
              %& &   \qquad \textsf{with}~\overline{P\!:\!m} & \quad\text{(Merges)} \\
              %&|&   \UsynLet{m}{M} & \text{Let binding} \\
      %\mprog &::=& \overline{\Uunit} & \text{Mixed program} \\
      r   &::=& \overline{m \mapsto m'} & \text{Module renaming} \\
    \end{array}
    \]

\caption{Component shapes and \unit{}s.}\label{fig:lcomponents}
\end{figure}



\begin{figure}
\begin{tabular}{p{0.45\textwidth} p{0.45\textwidth}}
\begin{verbatim}
component base
    exposed-module: W
component p
    required-signature: A
    required-signature: B
    exposed-module: Y
component q
    required-signature: A
    exposed-module: X
\end{verbatim}
&
\begin{verbatim}
component r
    required-signature: A
    mixin: base (W)
    mixin: p (Y) requires (B)
    mixin: q (X as B)
    reexported-module: Y as Z
\end{verbatim}
\end{tabular}
  \caption{Our running example.}\label{fig:resolved-example}
\end{figure}

\begin{figure}
    \[
    \begin{array}{l}
      \UsynUnitH{\cidl{base}}{} \haspr \{\provMod{W}{\icid{base}{}}{W}\}  \\
      %\quad \UsynLet{W}{\Mod{\icid{base}{}}{W}} \\
      \quad \UsynMod{\modname{W}(\texttt{I}(..))}{\texttt{data I = MkI I; f (MkI i) = i}} \\
      \\
      \UsynUnitH{\cidl{p}}{\hv{\modname{A}}~\hv{\modname{B}}}
        \haspr \{
            \provMod{Y}{%
                \icid{\cidl{p}}{ \subst{A}{\holevar{A}}, \subst{B}{\holevar{B}}  }%
            }{Y} \} \\
      \quad \UsynSig{A}{\texttt{data J}} \\
      \quad \UsynSig{B}{\texttt{data K}} \\
      %\quad \UsynLet{Y}{\MOD{p}{\substHole{A}, \substHole{B}}{Y}} \\
      \quad \UsynMod{Y}{\texttt{import A; import B; data L = MkL J K}} \\
      \\
      \UsynUnitH{\cidl{q}}{\hv{\modname{A}}}
        \haspr \{ \provMod{X}{\icid{\cidl{q}}{\subst{A}{\holevar{A}}}}{X} \}
      \\
      \quad \UsynSig{\modname{A}~(\texttt{I}(..))}{\texttt{data I = MkI I}} \\
      %\quad \UsynLet{X}{\MOD{q}{\substHole{A}}{X}} \\
      \quad \UsynMod{\modname{X}~(\texttt{I}(..), \texttt{K}(..))}{\texttt{import A; data K = MkK I}} \\
      \\
      \UsynUnitH{\cidl{r}}{\hv{\modname{A}}}
        \haspr \{
        \provMod{Z}{\icid{\cidl{p}}{%
                 \subst{A}{\holevar{A}},
                 \substMod{B}{\icid{\cidl{q}}{\subst{A}{\holevar{A}}}}{X}
             }}{Y} \}
        \\
      \quad \UsynDep{\icid{base}{}}{ \rename{W}{W} } \\
      %\quad\quad \textsf{with}~\Mod{\icid{\cidl{q}}{\substHole{A}}}{A},
      %           \Mod{\icid{\cidl{p}}{\substHole{A}, \subst{B}{\ldots}}}{A} \\
      \quad \UsynDep{\icid{\cidl{q}}{\substHole{A}}}{ \rename{X}{B} } \\
      \quad \UsynDep{\icid{\cidl{p}}{\substHole{A}, \substMod{B}{\icid{\cidl{q}}{\substHole{A}}}{X}}}{ \rename{Y}{Y} } \\
      \quad \mathsf{signature}~\modname{A}~(\texttt{I}(..))~\{ \texttt{import W(I(..))} \} \\
    \end{array}
    \]

  \caption{\Unit{}s. Each component is ordered and annotated with its provided modules, as
    $\textsf{component}~p~\overline{\protect\hv{m}}\haspr\{\provs\}$.}\label{fig:linked-example}
\end{figure}

\begin{figure}
    \[
    \begin{array}{l}
    \cidl{base}
        : \left\{\right\} \rightarrow
          \left\{
            \modname{W}
            : \begin{array}{l}
                \UobjIface\: (\MOD{base}{}{W}.\texttt{I}, \MOD{base}{}{W}.\texttt{f} ) \\
                \quad\texttt{data I :: * = MkI}\ \MOD{base}{}{W}.\texttt{I} \\
                \quad\texttt{f ::}~\MOD{base}{}{W}.\texttt{I}~\rightarrow~\MOD{base}{}{W}.\texttt{I}
            \end{array}
          \right\}
    \\[2em]
    \cidl{p} : \forall \hv{A} \hv{B}.\, \forall \nhv{\texttt{A.J}} \nhv{\texttt{B.K}}. \\
    \quad
    \left\{
        \modname{A}
          : \begin{array}{l}
                \UobjIface\: (\nhv{\texttt{A.J}}) \\
                \quad\texttt{data J :: *}
            \end{array},\,
        \modname{B}
          : \begin{array}{l}
                \UobjIface\: (\nhv{\texttt{B.K}}) \\
                \quad\texttt{data K :: *}
            \end{array}
    \right\}
    \rightarrow \\
    \quad
    \left\{
        \modname{Y}
          : \begin{array}{l}
                \UobjIface\: (\MOD{p}{\substHole{A}, \substHole{B}}{Y}.\texttt{L}) \\
                \quad\texttt{data L :: * = MkL \nhv{\texttt{A.J}} \nhv{\texttt{B.K}}}
            \end{array}
    \right\}
    \\[2em]
    \cidl{q} : \forall \hv{A}.\, \forall \nhv{\texttt{A.I}}. \\
    \quad
    \left\{
        \modname{A}
          : \begin{array}{l}
                \UobjIface\: (\nhv{\texttt{A.I}}) \\
                \quad\texttt{data I :: * = MkI}\ \nhv{\texttt{A.I}}
            \end{array}
    \right\}
    \rightarrow \\
    \quad
    \left\{
        \modname{X}
          : \begin{array}{l}
                \UobjIface\: (\nhv{\texttt{A.I}}, \MOD{q}{\substHole{A}}{X}.\texttt{K}) \\
                \quad\texttt{data K :: * = MkK \nhv{\texttt{A.I}}}
            \end{array}
    \right\}
    \\[2em]
    \cidl{r} : \forall \hv{A}.\, \forall \nhv{\texttt{A.J}}. \\
    \quad
    \left\{
        \modname{A}
          : \begin{array}{l}
                \UobjIface\: (\MOD{base}{}{W}.\texttt{I}, \nhv{\texttt{A.J}}) \\
                \quad\texttt{data J :: *}
            \end{array}
    \right\}
    \rightarrow
    \left\{
    \right\}
    \end{array}
    \]

\caption{Component types.  The full syntax for types is in Figure~\ref{fig:haskell-semantics}.}
\label{fig:typing-example}
\end{figure}
