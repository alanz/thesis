%!TEX root = paper.tex
\chapter{Introduction}

The universal organizing principle for large software systems in
programming languages today is the \emph{package}, the unit by which
reusable code may be versioned and distributed.  However, most package systems
provide only a weak form of modularity, where packages depend directly
on other packages.  A stronger form of modularity would
support \emph{separate modular development}, where a package may be
typechecked against an \emph{interface} of its dependency.  While
such facilities have been implemented as extensions to the core
language (e.g., the ML module system), these extensions say little
about modularity in the \emph{package language}, which is generally
independent from the core language and implemented by a separate tool.

The Backpack package system~\cite{backpack}
(hereafter called \OldBackpack{}) broke new ground, arguing that \emph{mixin
packages} could be a good fit for providing package-level modularity.
Mixin packages consist of defined modules (provisions) and declared
signatures (requirements); these packages can be combined together
through a process of mixin linking, which wires up provisions with
requirements.  Mixin packages fit very naturally into the existing
patterns of use for packages. Moreover, since they extend only the package
language they can be retrofitted onto Haskell without requiring ``yet
another type system extension.''  Finally, mixin linking helps avoid the
preponderance of \emph{sharing constraints}
and the so-called ``fully-functorized'' style commonly associated with
ML functors.

There is just one problem: \OldBackpack{} was never implemented.  Worse, it
cannot be implemented---at least, not as an extension to the package
manager.  The problem is that the semantics of \OldBackpack{} were closely entwined
with the semantics of Haskell itself. It did not respect the
traditional abstraction barrier between the compiler and package
manager---a direct implementation would require close coupling between
the two.

Thus motivated, we describe how to divide
\OldBackpack{} across the abstraction barrier between the package manager and
the compiler; we call our system \Backpack{}.  We consider separately the problem of
\emph{mixin linking}, which is indifferent to Haskell source code, and
the problem of \emph{typechecking against interfaces}, which is purely
the concern of the compiler.  To focus the paper, we do not address
mutual recursion between packages, allowing us to avoid some orthogonal
technical complications. We believe that in practice this is a minor
limitation.

Specifically, our contributions are as follows:
\begin{itemize}

    \item We describe a package language which can be \emph{mixin
    linked} without knowing anything about the Haskell programming
    language.  This gives us a language agnostic mechanism for
    expressing separate modular development, in contrast to
    \OldBackpack{}, which relies on critically on the import structure
    of Haskell modules in its semantics.  As a result, \Backpack{}
    employs a far simpler mixin linking procedure essentially equivalent
    to early descriptions of mixin linking in the literature.  As an
    added bonus, our new package language is order-independent, which is
    essential for backwards-compatibility with Haskell's existing
    package format.

    \item To express the results of mixin linking, we introduce the
    \emph{\unit{} language}, an intermediate representation that
    represents all instantiations explicitly.  This language is
    ``just'' ML-style applicative functors, but with a twist:
    unfilled requirements of dependency are propagated to the requirements
    of the enclosing package.  The effect is that \Backpack{}, as a
    whole, has the same mix-in semantics that were pioneered by \OldBackpack{}.

    \item We describe how to modify a real world compiler like GHC to
    implement the necessary instantiation and merging operations
    required by the \unit{} language.  Because the \unit{} language
    specifies instantiations explicitly, it is an easy matter to perform
    syntactic substitutions to form the instantiated versions of a
    \unit{}.  To handle signature merging in the presence of \emph{type
    synonyms} (not addressed in \OldBackpack{}), we describe a novel
    algorithm which takes advantage of lazy evaluation to avoid the need
    for a type computation pass (as seen in RMC) or bidirectional type
    lookup (as seen in MixML).

%   \item \Backpack{} stakes out a new point in the design space,
%   with an emphasis on practicality.  Two particular decisions stand
%   out. First, it eliminates \OldBackpack{}'s shaping pass, giving
%   up accuracy in module loops for less work upon recompilation.
%   Second, it tracks requirements at the package level, rather than
%   the module level, letting us straightforwardly map build products
%   into traditional shared and static libraries.

    \item This is not a paper design: Backpack has been fully
    implemented in the upcoming GHC 8.2 and cabal-install 2.0.  Although
    the true test of \Backpack{} would be
    ``Backpack''ing in the wild and seeing how the wider community
    uses it, we have done a number of case studies to give evidence
    that \Backpack{} works.  Among other things, these case studies
    have motivated the introduction of \emph{signature thinning}
    and how Backpack interoperates with Cabal's existing dependency
    solver.

\end{itemize}
%
Although the idea of separating the core language and the module/package
language is not novel~\cite{leroy:modular,milner+:def-of-sml-revised,rossberg+:f-ing}, we are the first to exploit these ideas in service
of an actual implementation, retrofitting strong modularity to an existing
programming language.  Some significant tasks remain to complete \Backpack{}
(Section~\ref{sec:limitations}),
but we have enough experience working with \Backpack{} that we believe that
this design is practical.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
