\begin{figure}

\fbox{\textbf{Module subtyping:} $\ctx \vdash M \le T$}

\[
\frac{
\begin{array}{c}
\ctx \vdash M : \UobjTau{\UNs'}{\Utys'~\Uinsts'~\Uimps'} \\
\UNs' \le \UNs \qquad
\Uimps' \le \Uimps \\
\forall n \in \UNs.\quad n \in \I{decls} \Rightarrow \ctx \vdash \UNs(n) \le \I{decls}(n) \\
\forall \I{inst} \in \I{insts}.\quad \ctx \vdash \{ M \} \cup \Uimps \cup \Uimps' ~\textsf{solves}~ \I{inst}
\end{array}
}{
%\ctx \vdash \UobjTau{\overline{N_i}\, \overline{N_j}}{\Utys\, \Uinsts} \le \UobjTau{\overline{N_i}}{\overline{\Uty'}\, \overline{\Uinst'}}
\ctx \vdash M \le \UobjTau{\UNs}{\Utys\, \Uinsts\, \Uimps}
}
\quad(\textsc{SMod})
\]

\fbox{\textbf{Export subtyping:} $\UNs \le \UNs$}

\[
\UNs\, \UNs' \le \UNs \quad(\textsc{SExport})
\]

\caption{
Every declaration is rooted by an export.  Any non-exported declarations are dropped when typechecking signature; if they are thinned out that is an error.
}


\end{figure}


\begin{figure}

\fbox{\textbf{Declaration subtyping:} $\ctx \vdash N \le \Uty$}

\[
\frac{
\begin{array}{c}
\ctx \vdash N : \Uty \qquad
\Uty :: \kappa \qquad
\Uty' :: \kappa' \\
\ctx \vdash \kappa =_\mathsf{hs} \kappa' \qquad
\ctx \vdash \Uty \le_\textsf{pre} \Uty'
\end{array}
}{
\ctx \vdash N \le \Uty'
}
\quad(\textsc{SDecl})
\]

\fbox{\textbf{Declaration pre-subtyping:} $\ctx \vdash \Uty \le_\textsf{pre} \Uty$}

\[
\ctx \vdash \texttt{data}~n~\overline{(a_i :: \kappa_i)} \le_\textsf{pre} \texttt{data}~n~\overline{(a_i :: \kappa'_i)}
\quad(\textsc{SAbsData})
\]
\[
\ctx \vdash \texttt{class}~n~\overline{(a_i :: \kappa_i)} \le_\textsf{pre} \texttt{class}~n~\overline{(a_i :: \kappa'_i)}
\quad(\textsc{SAbsClass})
\]
\[
\begin{array}{c}
\ctx \vdash \texttt{type family}~n~\overline{(a_i :: \kappa_i)} :: \kappa ~\texttt{where ..} \\
\qquad\qquad\le_\textsf{pre} \texttt{type family}~n~\overline{(a_i :: \kappa'_i)} :: \kappa' ~\texttt{where ..}
\end{array}
\quad(\textsc{SAbsClosedTF})
\]
\[
\ctx \vdash \texttt{type family}~n~\overline{(a_i :: \kappa_i)} \le_\textsf{pre} \texttt{type family}~n~\overline{(a_i :: \kappa'_i)}
\quad(\textsc{SOpenTF})
\]

% Only slightly non-trivial pre-subtyping relations

\[
\frac{
\ctx;\, \overline{a_i :: \kappa_i} \vdash \I{dinfo} =_\textsf{hs} \I{dinfo}'
}{
\ctx \vdash \texttt{data}~n~\overline{(a_i :: \kappa_i)} ~\texttt{where}~ \I{dinfo} \le_\textsf{pre} \texttt{data}~n~\overline{(a_i :: \kappa'_i)} ~\texttt{where}~ \I{dinfo}'
}
\quad(\textsc{SData})
\]

\[
\frac{
\ctx;\, \overline{a_i :: \kappa_i} \vdash \I{ntinfo} =_\textsf{hs} \I{ntinfo}'
}{
\ctx \vdash \texttt{newtype}~n~\overline{(a_i :: \kappa_i)} = \I{ntinfo} \le_\textsf{pre} \texttt{newtype}~n~\overline{(a_i :: \kappa'_i)} = \I{ntinfo}'
}
\quad(\textsc{SNewtype})
\]

\[
\frac{
\ctx;\, \overline{a_i :: \kappa_i} \vdash \tau =_\textsf{hs} \tau'
}{
\ctx \vdash \texttt{type}~n~\overline{(a_i :: \kappa_i)} = \tau \le_\textsf{pre} \texttt{type}~n~\overline{(a_i :: \kappa'_i)} = \tau'
}
\quad(\textsc{SType})
\]

\[
\frac{
\ctx;\, \overline{a_i :: \kappa_i} \vdash \I{clinfo} =_\textsf{hs} \I{clinfo}'
}{
\ctx \vdash \texttt{class}~n~\overline{(a_i :: \kappa_i)} ~\texttt{where}~ \I{clinfo} \le_\textsf{pre} \texttt{class}~n~\overline{(a_i :: \kappa'_i)} ~\texttt{where}~ \I{clinfo}'
}
\quad(\textsc{SClass})
\]

\[
\frac{
\ctx;\, \overline{a_i :: \kappa_i} \vdash \I{tfinfo} =_\textsf{hs} \I{tfinfo}'
}{
\begin{array}{l}
\ctx \vdash \texttt{type family}~n~\overline{(a_i :: \kappa_i)} ~\texttt{where}~ \I{tfinfo}
\\ \qquad \le_\textsf{pre} \texttt{type family}~n~\overline{(a_i :: \kappa'_i)} ~\texttt{where}~ \I{tfinfo}'
\end{array}
}
\quad(\textsc{SClosedTF})
\]

\[
\frac{
\ctx \vdash \tau =_\textsf{hs} \tau'
}{
\ctx \vdash n :: \tau \le_\textsf{pre} n :: \tau'
}
\quad(\textsc{SValue})
\]

% Nontrivial pre-subtyping relations

\begin{mdframed}
\[
\ctx \vdash \texttt{data}~n~\overline{(a_i :: \kappa_i)} ~\texttt{where}~ \I{dinfo} \le_\textsf{pre} \texttt{data}~n~\overline{(a_i :: \kappa'_i)}
\quad(\textsc{SDataAbsData})
\]
\[
\ctx \vdash \texttt{newtype}~n~\overline{(a_i :: \kappa_i)} :: \kappa = \tau \le_\textsf{pre} \texttt{data}~n~\overline{(a_i :: \kappa'_i)}
\quad(\textsc{SNewtypeAbsData})
\]
% Nullary type synonym!
\[
\frac{
\ctx \vdash \tau ~\textsf{has no type family applications}
}{
\ctx \vdash \texttt{type}~n :: \kappa = \tau \le_\textsf{pre} \texttt{data}~n~\overline{a_i :: \kappa'_i}
}
\quad(\textsc{STypeAbsData})
\]
\[
\ctx \vdash \texttt{class}~n~\overline{(a_i :: \kappa_i)}~\texttt{where}~ \I{clinfo} \le_\textsf{pre} \texttt{class}~n~\overline{(a_i :: \kappa'_i)}
\quad(\textsc{SClassAbsClass})
\]
\[
\ctx \vdash \texttt{type}~n :: \kappa = \tau \le_\textsf{pre} \texttt{class}~n~\overline{(a_i :: \kappa'_i)}
\quad(\textsc{STypeAbsClass})
\]
\[
\begin{array}{c}
\ctx \vdash \texttt{type family}~n~\overline{(a_i :: \kappa_i)} :: \kappa ~\texttt{where}~ \I{tfinfo} \\
\le_\textsf{pre} \texttt{type family}~n~\overline{(a_i :: \kappa'_i)} :: \kappa' ~\texttt{where ..}
\end{array}
\quad(\textsc{SClosedTFAbsClosedTF})
\]
\end{mdframed}
\caption{Subtyping relations.}
%   For concision, this relation is factored into
%   subtyping relation, and a pre-subtyping relation which doesn't consider kind
%   equality.  The boxed relations are the nontrivial subtyping relations, while
%   the rest are reflexive up to kind and type equivalence in Haskell.
\end{figure}
